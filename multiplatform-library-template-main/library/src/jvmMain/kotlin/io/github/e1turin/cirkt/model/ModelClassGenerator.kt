package io.github.e1turin.cirkt.model

import com.squareup.kotlinpoet.*
import io.github.e1turin.cirkt.arcilator.ModelInfo
import io.github.e1turin.cirkt.arcilator.StateInfo
import io.github.e1turin.cirkt.state.StateProjectionType
import java.lang.foreign.Arena
import java.lang.foreign.MemorySegment
import java.lang.invoke.MethodHandle
import java.nio.file.Paths

internal class ModelClassGenerator(
    private val modelInfo: ModelInfo,
    private val openModelClass: Boolean = false,
    private val openLibraryClass: Boolean = false,
    private val internalStateProjections: Boolean = false,
    private val allStateProjectionsOpen: Boolean = false,
    private val allStateProjectionsMutable: Boolean = false,
) {
    private val modelName = modelInfo.name.replaceFirstChar { it.uppercase() }
    private val modelClassName: String = "${modelName}Model"
    private val modelLibraryName: String = "${modelName}Library"

    init {
        if (openModelClass.not() && allStateProjectionsOpen) {
            throw IllegalArgumentException("Redundant open properties for final class. Make model class open or remove open state projections.")
        }
    }

    fun generateFileSpec(
        packageName: String = "",
    ): FileSpec {
        val companion = companion(packageName)

        val modelClass = modelClass(companion)

        val modelLibraryClass = modelLibraryClass()

        val className = modelInfo.name.replaceFirstChar { it.uppercase() }
        val fileSpec = FileSpec.builder(packageName, className)
            .addFileComment("""
                
                Generated by https://github.com/e1turin/cirkt
                
            """.trimIndent())
            .addType(modelClass)
            .addType(modelLibraryClass)
            .build()

        return fileSpec
    }


    private fun modelLibraryClass(): TypeSpec {
        val arenaParam = ParameterSpec.builder("arena", Arena::class)
            .defaultValue(DEFAULT_ARENA)
            .build()

        val nameParam = ParameterSpec.builder("name", String::class)
            .build()

        val builder = TypeSpec.classBuilder(modelLibraryName)

        if (openLibraryClass) {
            builder.addModifiers(KModifier.OPEN)
        }

        return builder
            .primaryConstructor(
                FunSpec.constructorBuilder()
                    .addParameter(nameParam)
                    .addParameter(arenaParam)
                    .build()
            )
            .superclass(ModelLibrary::class)
            .addSuperclassConstructorParameter(nameParam.name)
            .addSuperclassConstructorParameter(arenaParam.name)
            .addSuperclassConstructorParameter("%S", "${modelInfo.name}_eval")
            .addSuperclassConstructorParameter("%S", modelInfo.initialFnSym)
            .addSuperclassConstructorParameter("%S", modelInfo.finalFnSym)
            .addProperties(
                listOf(
                    modelLibraryPropertyTemplate("evalFunctionHandle", "evalFnSym", "${modelInfo.name}_eval"),
                    modelLibraryPropertyTemplate("initialFunctionHandle", "initialFnSym", modelInfo.initialFnSym),
                    modelLibraryPropertyTemplate("finalFunctionHandle", "finalFnSym", modelInfo.finalFnSym)
                )
            )
            .build()
    }


    private fun modelClass(
        companion: TypeSpec
    ): TypeSpec {
        val properties = modelInfo.states
            .filter { internalStateProjections || it.isIoPort() }
            .map { stateProjectionProperty(it) }

        val stateParam = ParameterSpec.builder("state", MemorySegment::class).build()
        val libParam = ParameterSpec.builder("lib", ModelLibrary::class).build()

        val builder = TypeSpec.classBuilder(modelClassName)

        if (openModelClass) {
            builder.addModifiers(KModifier.OPEN)
        }

        return builder
            .primaryConstructor(
                FunSpec.constructorBuilder()
                    .addParameter(stateParam)
                    .addParameter(libParam)
                    .build()
            )
            .superclass(Model::class)
            .addSuperclassConstructorParameter("%L", MODEL_NAME_CONST_NAME)
            .addSuperclassConstructorParameter(stateParam.name)
            .addSuperclassConstructorParameter(libParam.name)
            .addSuperclassConstructorParameter("%L", NUM_STATE_BYTES_CONST_NAME)
            .addProperties(properties)
            .addFunctions(
                listOf(
                    evalFunction(),
                    initialFunction(),
                    finalFunction()
                )
            )
            .addType(companion)
            .build()
    }

    private fun companion(
        packageName: String,
    ): TypeSpec {
        val arenaParam = ParameterSpec.builder("arena", Arena::class).build()
        val libraryNameParam = ParameterSpec.builder("libraryName", String::class).build()
        val libraryArenaParam = ParameterSpec.builder("libraryArena", Arena::class)
            .defaultValue(DEFAULT_ARENA)
            .build()

        val instanceFunction = FunSpec.builder("instance")
            .addParameter(arenaParam)
            .addParameter(libraryNameParam)
            .addParameter(libraryArenaParam)
            .returns(
                ClassName(packageName, modelClassName),
            )
            .addStatement(
                "return ${modelClassName}(${arenaParam.name}.allocate($NUM_STATE_BYTES_CONST_NAME), " +
                    "$modelLibraryName(${libraryNameParam.name}, ${libraryArenaParam.name}))"
            )
            .build()

        return TypeSpec.companionObjectBuilder()
            .addProperty(
                PropertySpec.builder(MODEL_NAME_CONST_NAME, String::class)
                    .addModifiers(KModifier.CONST)
                    .initializer("%S", modelInfo.name)
                    .build()
            )
            .addProperty(
                PropertySpec.builder(NUM_STATE_BYTES_CONST_NAME, Long::class)
                    .addModifiers(KModifier.CONST)
                    .initializer("%LL", modelInfo.numStateBytes)
                    .build()
            )
            .addFunction(instanceFunction)
            .build()
    }

    private fun stateProjectionProperty(state: StateInfo): PropertySpec {
        val stateProjectionName = if (state.isIoPort()) {
            state.name.replaceFirstChar { c -> c.lowercase() }
        } else {
            state.name.replaceFirstChar { c -> c.uppercase() }.let { "internal${it}" }
        }

        val delegate = when (state.type) {
            StateProjectionType.INPUT -> STATE_DELEGATE_INPUT
            StateProjectionType.OUTPUT -> STATE_DELEGATE_OUTPUT
            StateProjectionType.REGISTER -> STATE_DELEGATE_REGISTER
            StateProjectionType.MEMORY -> STATE_DELEGATE_MEMORY
            StateProjectionType.WIRE -> STATE_DELEGATE_WIRE
        }

        val builder = PropertySpec.builder(stateProjectionName, getTypeForNumBits(state.numBits))

        if (openModelClass && allStateProjectionsOpen) {
            builder.addModifiers(KModifier.OPEN)
        }

        return builder.mutable(allStateProjectionsMutable || state.type == StateProjectionType.INPUT)
            .delegate(
                CodeBlock.of(
                    "%M<%T>(%L)",
                    delegate,
                    getTypeForNumBits(state.numBits),
                    state.offset,
                )
            )
            .build()
    }

    private fun evalFunction(): FunSpec =
        FunSpec.builder("eval")
            .addStatement("lib.evalFunctionHandle.invokeExact(state)")
            .build()

    private fun initialFunction(): FunSpec =
        FunSpec.builder("initial")
            .addStatement("lib.initialFunctionHandle.invokeExact(state)")
            .build()

    private fun finalFunction(): FunSpec =
        FunSpec.builder("final")
            .addStatement("lib.finalFunctionHandle.invokeExact(state)")
            .build()

    private fun modelLibraryPropertyTemplate(
        propertyName: String,
        librarySymbolName: String,
        librarySymbolValue: String
    ): PropertySpec {
        val builder = PropertySpec.builder(propertyName, MethodHandle::class)

        if (librarySymbolValue.isNotEmpty()) {
            builder.initializer(
                CodeBlock.builder().addStatement("%L", "functionHandle($librarySymbolName)").build()
            )
        } else {
            builder.getter(
                FunSpec.getterBuilder()
                    .addCode(
                        CodeBlock.builder()
                            .add("throw NotImplementedError(\"Symbol $librarySymbolName is not defined\")")
                            .build()
                    )
                    .build()
            )
        }

        return builder
            .addModifiers(KModifier.OVERRIDE)
            .build()
    }


    private fun getTypeForNumBits(numBits: UInt): TypeName = when {
        numBits <= 8u -> BYTE
        numBits <= 16u -> SHORT
        numBits <= 32u -> INT
        numBits <= 64u -> LONG
        else -> throw IllegalArgumentException("Unsupported numBits: $numBits")
    }

    private fun StateInfo.isIoPort(): Boolean {
        return this.type in IO_TYPES
    }

    companion object {
        val IO_TYPES = setOf(StateProjectionType.INPUT, StateProjectionType.OUTPUT)
        val DEFAULT_ARENA = CodeBlock.builder().add("Arena.ofAuto()").build()

        const val MODEL_NAME_CONST_NAME = "MODEL_NAME"
        const val NUM_STATE_BYTES_CONST_NAME = "NUM_STATE_BYTES"

        val STATE_DELEGATE_INPUT = MemberName("io.github.e1turin.cirkt.state", "input")
        val STATE_DELEGATE_OUTPUT = MemberName("io.github.e1turin.cirkt.state", "output")
        val STATE_DELEGATE_REGISTER = MemberName("io.github.e1turin.cirkt.state", "register")
        val STATE_DELEGATE_MEMORY = MemberName("io.github.e1turin.cirkt.state", "memory")
        val STATE_DELEGATE_WIRE = MemberName("io.github.e1turin.cirkt.state", "wire")
    }

}



